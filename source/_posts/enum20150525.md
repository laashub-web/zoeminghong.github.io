---
title: Java枚举全解析
tags: code
date: 2016-05-25
---
enum关键字与class和interface地位相同，其一样有成员变量、方法、可以实现一个或多个接口，也可以有构造器
<!-- more -->
### 枚举类与普通类的区别

- 枚举类的父类是java.lang.Enum类
- 非抽象枚举类默认使用final修饰，不能存在子类
- 枚举类的构造器只能使用private修饰符，默认就是private
- 枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远不能产生实例，列出的实例，系统会自动添加public static final修饰

> 抽象的枚举类，系统默认使用abstract修饰，而不用final修饰

```java
package com.em;

public enum EmFestival {
	//会产生如下四个实例
	SPRING,SUMMER,FALL,WINTER;

}

```

> 枚举值就代表可能会产生的实例

```java
package com.em;

public class FestivalTest {
	public static String jude(EmFestival v){
		switch (v) {
		case SPRING:
			return "春天";
		case SUMMER:
			return "夏天";
		case FALL:
			return "秋天";
		case WINTER:
			return "冬天";
		}
		return null;
	}
	
	public static void main(String[] args) {
		System.out.println(jude(EmFestival.SPRING));
	}
}

```

### 为什么使用枚举类？

- 存在命名空间，可以将其他的静态常量区分开
- 打印输出的意义明确，不想普通常量那样，都用数字表示含义，无法直接表达含义

### 枚举类方法

- compare(E o)：用于与指定的枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例进行比较。如果该枚举对象位于指定枚举对象之后，则返回正整数
- name()：返回此枚举实例的名称
- ordinal()：返回枚举值在枚举类中的索引值（从0开始）
- toString()：与name方法一致，推荐使用toString
- valueOf()：一个静态方法，用于返回指定枚举类中指定名称的枚举值

```java
package com.em;


public enum EmFestival {
	//会产生如下四个实例
	SPRING("春天"),SUMMER("夏天"),FALL("秋天"),WINTER("冬天");
	private final String fest;
	private EmFestival(String fest){
		this.fest=fest;
	}
	public String getFest() {
		return fest;
	}
	
}

```

### 实现接口的枚举类

枚举类实现接口，与正常类没有什么区别

```java
package com.em;

import java.io.FileDescriptor;
import java.io.IOException;

import sun.nio.ch.SelChImpl;
import sun.nio.ch.SelectionKeyImpl;


public enum EmFestival implements SelChImpl{
//	会产生如下四个实例
	SPRING("春天"),SUMMER("夏天"),FALL("秋天"),WINTER("冬天");

	@Override
	public boolean isOpen() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void close() throws IOException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public FileDescriptor getFD() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int getFDVal() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void kill() throws IOException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void translateAndSetInterestOps(int arg0, SelectionKeyImpl arg1) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean translateAndSetReadyOps(int arg0, SelectionKeyImpl arg1) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean translateAndUpdateReadyOps(int arg0, SelectionKeyImpl arg1) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public int validOps() {
		// TODO Auto-generated method stub
		return 0;
	}

	private final String fest;
	private EmFestival(String fest){
		this.fest=fest;
	}
	public String getFest() {
		return fest;
	}
	
}

```

### 包含抽象方法的枚举类

枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（因为系统自动会添加abastract），但因为枚举类需要显式创建枚举值，而不是作为父类，所以定义每个枚举值时必须为抽象方法提供实现，否则出现编译错误

```java
package com.em;

public enum EmFestival {
	// 会产生如下四个实例
	SPRING("春天") {
		@Override
		public String getFestival() {
			return "春天";
		}
	},
	SUMMER("夏天") {
		@Override
		public String getFestival() {
			return "夏天";
		}
	},
	FALL("秋天") {
		@Override
		public String getFestival() {
			return "秋天";
		}
	},
	WINTER("冬天") {
		@Override
		public String getFestival() {
			return "冬天";
		}
	};
	public abstract String getFestival();

	private final String fest;

	private EmFestival(String fest) {
		this.fest = fest;
	}

	public String getFest() {
		return fest;
	}

}

```