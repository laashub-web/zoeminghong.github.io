---
title: MongoDB的Spring配置使用
tags: code
date: 2016-07-05
---

Spring-data对MongoDB进行了很好的支持，接下来就讲解一下关于Spring对MongoDB的配置和一些正常的使用

我下面的工程使用的是Spring的Java配置的方式和Maven构建

具体的工程代码大家可以访问我的Github地址:[https://github.com/zoeminghong/springmvc-javaconfig](https://github.com/zoeminghong/springmvc-javaconfig)

<!-- more -->

### ①MongoDB的必要配置

```java
package springmvc.rootconfig;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.core.MongoClientFactoryBean;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;

import com.mongodb.Mongo;

@Configuration
// 启用MongoDB的Repository功能，会对其Repositories自动扫描
@EnableMongoRepositories(basePackages = "springmvc.orders.db")	
public class MongoConfig {
	// MongoClient配置
	@Bean
	public MongoClientFactoryBean mongo() {
		MongoClientFactoryBean mongo = new MongoClientFactoryBean();
		mongo.setHost("localhost");
      //MongoCredential credential=MongoCredential.createCredential(env.getProperty("mongo.username"), "OrdersDB",env.getProperty("mongo.password").toCharArray());
//		mongo.setCredentials(new MongoCredential[]{credential});
        //还可以对端口进行配置
		return mongo;
	}

	// Mongo Template配置
	@Bean
	public MongoOperations mongoTemplate(Mongo mongo) {
        //OrdersDB就是Mongo的数据库
		return new MongoTemplate(mongo, "OrdersDB");
	}
}
```

为了访问数据库的时候，我们可能还需要帐号密码

```java
MongoCredential credential=MongoCredential.createCredential(env.getProperty("mongo.username"), "OrdersDB",env.getProperty("mongo.password").toCharArray());
mongo.setCredentials(new MongoCredential[]{credential});
```

### ②为模型添加注解

```java
package springmvc.bean;

import java.util.Collection;
import java.util.LinkedHashSet;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;
//这是文档
@Document
public class Order {
  //指定ID
	@Id
	private String id;
    //为域重命名
	@Field("client")
	private String customer;
	private String type;
	 private Collection<Item> items=new LinkedHashSet<Item>();
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getCustomer() {
		return customer;
	}
	public void setCustomer(String customer) {
		this.customer = customer;
	}
	public String getType() {
		return type;
	}
	public void setType(String type) {
		this.type = type;
	}
	public Collection<Item> getItems() {
		return items;
	}
	public void setItems(Collection<Item> items) {
		this.items = items;
	}
	
}

```

```java
package springmvc.bean;

public class Item {

	private Long id;
	private Order order;
	private String product;
	private double price;
	private int quantity;
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public Order getOrder() {
		return order;
	}
	public void setOrder(Order order) {
		this.order = order;
	}
	public String getProduct() {
		return product;
	}
	public void setProduct(String product) {
		this.product = product;
	}
	public double getPrice() {
		return price;
	}
	public void setPrice(double price) {
		this.price = price;
	}
	public int getQuantity() {
		return quantity;
	}
	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}
	
}

```

| 注解        | 描述                              |
| --------- | ------------------------------- |
| @Document | 标示映射到mongoDB文档上的领域对象            |
| @ID       | 标示某个为ID域                        |
| @DbRef    | 标示某个域要引用其他的文档，这个文档有可能位于另外一个数据库中 |
| @Field    | 为文档域指定自定义的元数据                   |
| @Version  | 标示某个属性用作版本域                     |

> 若不使用@Field注解，域名就与Java属性相同
>
> 上面之所以Item的Java类为什么没有@Document注解，是因为我们不会单独想Item持久化为文档

### ③使用MongoTemplate访问MongoDB

```java
package springmvc.web;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import springmvc.bean.Order;
import springmvc.orders.db.OrderRepository;

@Controller
public class HomeController {
	@Autowired
	MongoOperations mongo;

	@RequestMapping(value = { "/", "index" }, method = RequestMethod.GET)
	public String index() {
		 long orderCount=mongo.getCollection("order").count();
		 System.out.println(orderCount);
//		Order order = new Order();
//		order.setId("1");
//		order.setCustomer("gg");
//		order.setType("2");
      //第二个参数是文档存储的名称
//		mongo.save(order,"order");
//		String orderId="1";
//		Order order=mongo.findById(orderId, Order.class);
//		System.out.println(order.getCustomer());
		return "index";
	}
}
```

> 在这里我们将MongoTemplate注入到一个类型为MongoOperations的属性中。MongoOperations是MongoTemplate所实现的接口，MongoOperations中存在很多文档操作方法
>
> MongoOperations其实已经能满足很多需求了

**如果还没有满足你的需求，接下来我就介绍一下，如何编写MongoDB Repository**

### 编写MongoDB Repository

```java
package springmvc.orders.db;

import java.util.List;

import org.springframework.data.mongodb.repository.MongoRepository;

import springmvc.bean.Order;

public interface OrderRepository extends MongoRepository<Order, String> {
	List<Order> findByCustomer(String c);

	List<Order> findByCustomerLike(String c);

	List<Order> findByCustomerAndType(String c, String t);

	List<Order> findByCustomerLikeAndType(String c, String t);
}

```

> 看到这里，大家有没有发现package的地址就是我们刚才@EnableMongoRepositories(basePackages = "springmvc.orders.db")的配置
>
> MongoRepository接口有两个参数，第一个是带有@Document注解的对象类型，也就是该Repository要处理的类型。第二个参数是带有@Id注解的属性类型

OrderRepository继承了MongoRepository中很多自带的方法

| 方法                                 | 描述                           |
| ---------------------------------- | ---------------------------- |
| long count()                       | 返回指定Repository类型的文档数量        |
| void delete(Iterable<? extends T>) | 删除与指定对象关联的所有文档               |
| void delete(T)                     | 删除与指定对象关联的文档                 |
| void delete(ID)                    | 根据ID删除某一个文档                  |
| void deleteAll();                  | 删除指定Repository类型的所有文档        |
| boolean exists(Object)             | 如果存在与指定对象相关联的文档，则返回true      |
| boolean exists(ID)                 | 如果存在与指定对象相关联的文档，则返回true      |
| List<T>findAll()                   | 返回指定Repository类型的所有文档        |
| List<T>findAll(Iterable<ID>)       | 返回指定文档ID对应的所有文档              |
| List<T>findAll(Pageable)           | 为指定Repository类型，返回分页且排序的文档列表 |
| List<T>findAll(Sort)               | 为指定Repository类型，返回排序后的所有文档列表 |
| T findOne(ID)                      | 为指定的ID返回单个文档                 |
| Save(terable<S>)                   | 保存指定Iterable中的所有文档           |
| save(<S>)                          | 为给定的对象保存一条文档                 |

上面的我们定义的四个方法都是我们自定义的方法，其方法名存在很多意义，不能随便定义

```java
List<Order> findByCustomer(String c);
```

find为查询动词，还可以是read、get、count等

Customer为断言，判断其行为

在断言中，会有一个或多个限制结果的条件。每个条件必须引用一个属性，并且还可以指定一种比较操作。如果省略比较操作符的话，那么这暗指是一种相等比较操作。不过，我们也可以选择其他的比较操作

| 类型                                      |
| --------------------------------------- |
| IsAfter、After、IsGreaterThan、GreaterThan |
| IsGreaterThanEqual、GreaterThanEqual     |
| IsBefore、Before、IsLessThan、LessThan     |
| IsLessThanEqual、LessThanEqual           |
| IsBetween、Between                       |
| IsNull、Null                             |
| IsNotNull、NotNull                       |
| IsIn、In                                 |
| IsNotIn、NotIn                           |
| IsStartingWith、StartingWith、StartsWith  |
| IsEndingWith、EndingWith、EndsWith        |
| IsContaining、Containing、Contains        |
| IsLike、Like                             |
| IsNotLike、NotLike                       |
| IsTure、True                             |
| IsFalse、False                           |
| Is、Equals                               |
| IsNot、Not                               |

other

| 类型                                      |
| --------------------------------------- |
| IgnoringCase、IgnoresCase、OrderBy、And、Or |

#### 指定查询

```java
@Query("{'customer':'Chuck Wagon','type':?0}")
List<Order> findChucksOrders(String t);
```

> @Query中给定的JSON将会与所有的Order文档进行匹配，并返回匹配的文档，这里的type属性映射成“？0”，这表明type属性应该与查询方法的第0个参数相等，如果有多个参数，则"?1".....

#### 混合自定义的功能

```java
package springmvc.orders.db;

import java.util.List;

import springmvc.bean.Order;

public interface OrderOperations {
	List<Order> findOrdersByType(String t);

}
```

```java
package springmvc.orders.db;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

import springmvc.bean.Order;

public class OrderRepositoryImpl implements OrderOperations {
	@Autowired
	private MongoOperations mongo;
	//将混合实现注入MongoOperations
	@Override
	public List<Order> findOrdersByType(String t) {
		String type =t.equals("Net")?"2":t;
		Criteria where=Criteria.where("type").is(type);
		Query query=Query.query(where);
		return mongo.find(query, Order.class);
	}
}

```

```java
package springmvc.orders.db;

import java.util.List;

import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import springmvc.bean.Order;
//继承OrderOperations接口
public interface OrderRepository extends MongoRepository<Order, String>,OrderOperations {
	List<Order> findByCustomer(String c);

	List<Order> findByCustomerLike(String c);

	List<Order> findByCustomerAndType(String c, String t);

	List<Order> findByCustomerLikeAndType(String c, String t);
	
	@Query("{'customer':'Chuck Wagon','type':?0}")
	List<Order> findChucksOrders(String t);
	
}
```

```java
package springmvc.web;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import springmvc.bean.Order;
import springmvc.orders.db.OrderRepository;

@Controller
public class HomeController {
	@Autowired
	MongoOperations mongo;
	@Autowired
	OrderRepository orderRepository;

	@RequestMapping(value = { "/", "index" }, method = RequestMethod.GET)
	public String index() {
		List<Order> list=orderRepository.findOrdersByType("2");
		System.out.println(list.size());
		return "index";
	}
}

```

> 以上这些关联起来的关键点是OrderRepositoryImpl，这个名字前半部分与OrderRepository相同，只是添加了一个“Impl”后缀。如果想更改该后缀，可以在MongoConfig类中更改为自己理想的后缀

```java
@EnableMongoRepositories(basePackages = "springmvc.orders.db",repositoryImplementationPostfix="Stuff")	
```

