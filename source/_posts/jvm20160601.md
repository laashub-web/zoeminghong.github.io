---
title: Java代理设计模式详解
tags: code
date: 2016-06-01
---
代理即通过代理类，找到适合你的实现类。相当于现实生活中的中介的角色，你想租房子，这个时候你又不想自己找房子，那你可以找中介，通过中介找到合适自己的房子，同时你也可以让中介帮你签合同等其他事宜。代理存在**静态代理和动态代理**两种
<!-- more -->
### 静态代理

```java
public interface Sourceable {  
    public void method();  
}  
```

```java
public class Source implements Sourceable {  
  
    @Override  
    public void method() {  
        System.out.println("the original method!");  
    }  
}  
```

```java
public class Proxy implements Sourceable {  
  
    private Source source;  
    public Proxy(){  
        super();  
        this.source = new Source();  
    }  
    @Override  
    public void method() {  
      //新增的处理，个性化处理
        before();  
        source.method();  
        atfer();  
    }  
    private void atfer() {  
        System.out.println("after proxy!");  
    }  
    private void before() {  
        System.out.println("before proxy!");  
    }  
}  
```

`测试类`

```java
public class ProxyTest {  
  
    public static void main(String[] args) {  
        Sourceable source = new Proxy();  
        source.method();  
    }  
  
}  
```

### 动态代理

**JDK动态代理、AOP动态代理**

Proxy提供了用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类

**创建动态代理类**

static Class<?>getProxyClass(ClassLoader loader,Class<?>...interfaces):创建一个动态代理类锁对应的Class对象，该代理类将实现interface所指定的多个接口，第一个ClassLoader 参数指生成动态代理类的类加载器。

**创建动态代理对象**

static Object newProxyInstance(ClassLoader loader,Class<?>...interfaces,InvocationHadnler h):直接创建一个动态代理对象，该代理对象的实现类实现了interfaces指定的系列接口，执行代理对象的每个方法时都会被替换执行InvocationHadnler对象的invoke方法

```java
public interface Colorable {
	 public void value();
}
```

```java
public class RedColor implements Colorable{
	 @Override
	    public void value() {
	        System.out.println("--------------red-------------");
	    }
}
```

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ColorableProxy implements InvocationHandler {

	private Colorable colorable;
	private Colorable proxy;

	public ColorableProxy(Colorable colorable) {
		this.colorable = colorable;
		this.proxy = (Colorable) Proxy.newProxyInstance(
				Colorable.class.getClassLoader(),
				new Class<?>[] { Colorable.class }, this);
	}

	public Colorable getProxy() {
		return proxy;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		String methodName = method.getName();

		System.out.println("===========starting invoke function:" + methodName
				+ "==========");

		Object result = method.invoke(colorable, args);

		System.out.println("=========== invoke function:" + methodName
				+ " success==========");
		return result;
	}

	public static void main(String[] args) {

		Colorable proxy = new ColorableProxy(new RedColor()).getProxy();
		//真正调用invoke方法是在这一步才被激发的，可以debug试一下
		proxy.value();
	}

}
```

`结果`

```tex
===========starting invoke function:value==========
--------------red-------------
=========== invoke function:value success==========
```

> proxy：代表动态代理对象
>
> method：代表正在执行的方法
>
> args:代表调用目标方法时传入的实参

#### AOP动态代理

![这里写图片描述](http://img.blog.csdn.net/20160601143838978)

```java
public interface Colorable {
	 public void value();
}
```

```java
public class RedColor implements Colorable{
	 @Override
	    public void value() {
	        System.out.println("--------------red-------------");
	    }
}
```

```java
public class ToolUtility {

	public void method(){
		System.out.println("运行工具方法");
	}
}
```

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ColorableAOProxy implements InvocationHandler {
	private Colorable colorable;
	private Colorable proxy;

	public ColorableAOProxy(Colorable colorable) {
		this.colorable = colorable;
		this.proxy = (Colorable) Proxy.newProxyInstance(
				Colorable.class.getClassLoader(),
				new Class<?>[] { Colorable.class }, this);
	}

	public Colorable getProxy() {
		return proxy;
	}

	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		ToolUtility tool = new ToolUtility();
		tool.method();
		String methodName = method.getName();
		System.out.println("===========starting invoke function:" + methodName
				+ "==========");
		Object result = method.invoke(colorable, args);

		System.out.println("=========== invoke function:" + methodName
				+ " success==========");
		return result;
	}

	public static void main(String[] args) {
		Colorable proxy = new ColorableAOProxy(new RedColor()).getProxy();
		// 真正调用invoke方法是在这一步才被激发的，可以debug试一下
		proxy.value();
	}
}
```

`结果`

```java
运行工具方法
===========starting invoke function:value==========
--------------red-------------
=========== invoke function:value success==========
```
